BACKEND
-------
I began by reading the instructions and interpreted the
backend task as needing to programmatically scan through each content
string, detect when a source ID (e.g. \[source123]) was mentioned, and
replace it with a proper hyperlink to the relevant source. Essentially a find
and replace. My assumption was that mock.json was meant to act as a static mock 
database and should not be edited directly. Instead, the server would return 
a processed version of it.

It's been quite some time since I last used Python (around December), so
to get my head back into it, I first sketched out the logic in JavaScript, 
the language I’m most comfortable with. This helped me mentally map out the steps:

* Iterate over each entry
* Check if each source ID appears in the content string
* If it does, replace it with an anchor tag using the source’s title and URL
* Separate cited and non-cited sources
* Attach a favicon URL based on the source domain

Once I was confident in the logic, I translated it into Python.
I kept all logic scoped to the `/data` endpoint as the task only called
for one route. Middleware would have been unnecessary for this case.

I used `urllib.parse` from Python’s standard library to extract domains for
the favicon URLs. I added those to each source as part of an enriched object.
I then returned both the original content and the processed version to give
the frontend flexibility.

To ensure data shape consistency, I added to the Pydantic schema, 
which I treated like a Python equivalent of TypeScript’s type system.
It helped ensure the returned data structure matched expectations, 
and made the contract between backend and frontend more robust.

I decided to return markdown formatted content. My thinking being it will 
make it easier to format on the frontend AND remove the need for dangerouslySetInnerHtml.
When Googling this topic, I found that the DOMPurify is a potential aternative solution.
I chose not go with this as I had concern over time constraits and the added 
complexity of sanitising HTML directly. The markdown felt like a nice middleground.

I'm aware that in real world applications, rendering trusted HTML is common 
(using dangerouslySetInnerHTM with properly sanitised input). I'm happy to adapt 
if this was the intended pattern.   

I initially created a static CATEGORIES map to clean up category keys
from the backend (e.g. turning benefits_and_tax_credits into something
more human-readable) and to add descriptions.
But this meant my homepage cards were only rendering categories listed
in that map. If new data came in with a new category, it wouldn’t show.
To fix this, I added logic to compare the backend category keys with the
static list and render fallback cards for any new ones. These use a
formatted title and a default description.
It’s not perfect, since the backend doesn’t supply descriptions, but it
keeps the UI dynamic and ensures new content isn’t ignored.

This was my first time implementing tests in Python. I used pytest as it appears to be 
the industry standard. Initially I tried a tests/ folder structure, but considering the size 
of the test and what I was testing, I decided to co locate the test file with main.py. 
It avoided any import path complexity. 


FRONTEND
--------

Styling - I can't pretend that I'm a hot shot web 'designer' 
so I thought it wise to stand of the shoulders of giants here.
Seeing as this is an CAB focussed project, then why not take inspiration
from existing CAB pages? So, that's what I did.  

Two areas which I am actively improving in are accessibility and testing.
I was able to get the general structure and functionality of the application
down in around 1.5 days. This meant I could spend any remaining time really 
focussing on accessibility and testing. 

ACCESSIBILITY
I wanted to make this application as accessible as possible, while also learning
proper accessibility patterns. I installed 'jsx-a11y' and used it in strict mode 
to help catch accessibility issues during development. It's the first time I've used 
this package and it was a nice experience being alerted to any obviously glaring issues.

Key improvements I implented included proper semantic HTML structure, descriptive ARIA
labels, keyboard nav support, and correct heading hierarchy. The jsx-a11y linter taught
me that using the right HTML element for the job is key, and reduces the need for complex 
aria attributes.

I used sources such as WCAG, MDN, A11y, WebAIM, and React docs to guide my implementation.
WebAIM was especially good for information on designign for screen readers 
as that's an area I'm admittedly very green on. 



